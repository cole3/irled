C51 COMPILER V7.08   IR                           12/06/2015 11:23:58 PAGE 1   


C51 COMPILER V7.08, COMPILATION OF MODULE IR
OBJECT MODULE PLACED IN ir.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE source\ir.c INCDIR(include) DEBUG 
                    -OBJECTEXTEND PRINT(.\ir.lst) PAGEWIDTH(79) PAGELENGTH(66) OBJECT(ir.obj)

line level    source

   1          /*
   2           * ir
   3           * using timer1 counter to invode interrupt because STC15F104E's 
             -ex int error.
   4           * timer0 is used to calculate high/low level's time.
   5          */
   6          
   7          #include "ir.h"
   8          #include "timer.h"
   9          #include "delay.h"
  10          #include "soft_uart.h"
  11          
  12          
  13          //#define CONFIG_RC3_CODE
  14          
  15          
  16          static bit ir_rcv_int = 0;
  17          
  18          
  19          void ir_rcv_isr(void)
  20          {
  21   1              Timer1_InterruptDisable();
  22   1              ir_rcv_int = 1;
  23   1      }
  24          
  25          void ir_rcv_t0_timer_cfg(void)
  26          {
  27   1              TIM_InitTypeDef tim_type;
  28   1      
  29   1              tim_type.TIM_Mode = TIM_16BitAutoReload;
  30   1              tim_type.TIM_Polity = 1;
  31   1              tim_type.TIM_Interrupt = DISABLE;
  32   1              tim_type.TIM_ClkSource = TIM_CLOCK_12T;
  33   1              tim_type.TIM_ClkOut = DISABLE;
  34   1              tim_type.TIM_Value = 0;
  35   1              tim_type.TIM_Run = DISABLE;
  36   1              tim_type.TIM_Isr = 0;
  37   1              Timer_Inilize(Timer0, &tim_type);
  38   1      }
  39          
  40          void ir_rcv_t1_timer_cfg(bit enable)
  41          {
  42   1              TIM_InitTypeDef tim_type;
  43   1      
  44   1              tim_type.TIM_Mode = TIM_16BitAutoReload;
  45   1              tim_type.TIM_Polity = PolityLow;
  46   1              tim_type.TIM_Interrupt = enable;
  47   1              tim_type.TIM_ClkSource = TIM_CLOCK_Ext;
  48   1              tim_type.TIM_ClkOut = DISABLE;
  49   1              tim_type.TIM_Value = 0xFFFF;
  50   1              tim_type.TIM_Run = enable;
  51   1              tim_type.TIM_Isr = ir_rcv_isr;
  52   1              Timer_Inilize(Timer1, &tim_type);
  53   1      }
  54          
  55          static unsigned int Ir_Get_Low()
C51 COMPILER V7.08   IR                           12/06/2015 11:23:58 PAGE 2   

  56          {
  57   1              unsigned int t = 0;
  58   1      
  59   1              TL0 = 0;
  60   1              TH0 = 0;
  61   1              TR0 = 1;
  62   1              while (!IR_REV && !(TH0 & 0x80));
  63   1      
  64   1              TR0 = 0;
  65   1              t = TH0;
  66   1              t <<= 8;
  67   1              t |= TL0;
  68   1      
  69   1              return t;
  70   1      }
  71          
  72          static unsigned int Ir_Get_High()
  73          {
  74   1              unsigned int t = 0;
  75   1      
  76   1              TL0 = 0;
  77   1              TH0 = 0;
  78   1              TR0 = 1;
  79   1              while (IR_REV && !(TH0 & 0x80));
  80   1      
  81   1              TR0 = 0;
  82   1              t = TH0;
  83   1              t <<= 8;
  84   1              t |= TL0;
  85   1      
  86   1              return t;
  87   1      }
  88          
  89          static bit nec_decode(unsigned char *key)
  90          {
  91   1              unsigned int temp;
  92   1              char i,j;
  93   1      
  94   1              temp = Ir_Get_High();
  95   1              if ((temp < 3686) || (temp > 4608))
  96   1              {
  97   2                      return 0;
  98   2              }
  99   1      
 100   1              for (i=0; i<4; i++)
 101   1              {
 102   2                      for (j=0; j<8; j++)
 103   2                      {
 104   3                              temp = Ir_Get_Low();
 105   3                              if ((temp < 184) || (temp > 737)) //200~800us
 106   3                                      return 0;
 107   3      
 108   3                              temp = Ir_Get_High();
 109   3                              if ((temp < 184) || (temp > 1843)) //200~2000us
 110   3                                      return 0;
 111   3      
 112   3                              key[i] >>= 1;
 113   3                              if (temp > 1032) //1120us
 114   3                                      key[i] |= 0x80;
 115   3                      }
 116   2              }
 117   1      
 118   1              return 1;
 119   1      }
C51 COMPILER V7.08   IR                           12/06/2015 11:23:58 PAGE 3   

 120          
 121          #ifdef CONFIG_RC3_CODE
              static bit rc5_decode(unsigned char *key)
              {
                      unsigned int temp, c = 0;
                      bit state = 1;
                      char i = 0, j;
              
                      while (1) //13 bit
                      {
                              temp = Ir_Get_High();
                              test[2] = temp;
                              if ((temp < 300) || (temp > 900)) //200~800us
                                      goto err;
              
                              if (temp > 600)
                              {
                                      state = !state;
                                      i++;
                              }
                              c |= state;
                              c <<= 1;
                              i++;
              
                              temp = Ir_Get_Low();
                              test[3] = temp;
                              if ((temp < 300) || (temp > 900)) //200~800us
                                      goto err;
              
                              if (temp > 600)
                              {
                                      state = !state;
                                      i++;
                              }
                              c |= state;
                              c <<= 1;
                              i++;
                      }
              
              err:
                      return 1;
              }
              #endif
 163          
 164          bit ir_rcv(unsigned char *key)
 165          {
 166   1              unsigned int temp;
 167   1              bit ret = 0;
 168   1              char i,j;
 169   1      
 170   1              if (!ir_rcv_int)
 171   1              {
 172   2                      return 0;
 173   2              }
 174   1      
 175   1              ir_rcv_t0_timer_cfg();
 176   1      
 177   1              temp = Ir_Get_Low();
 178   1              if (temp > 3000 && temp < 8755)
 179   1              {
 180   2                      ret = nec_decode(key);
 181   2              }
 182   1      #ifdef CONFIG_RC3_CODE
                      else if (temp <= 3000)
C51 COMPILER V7.08   IR                           12/06/2015 11:23:58 PAGE 4   

                      {
                              ret = rc5_decode(key);
                      }
              #endif
 188   1      
 189   1              ir_rcv_int = 0;
 190   1              Timer1_InterruptEnable();
 191   1      
 192   1              return ret;
 193   1      }
*** WARNING C280 IN LINE 168 OF SOURCE\IR.C: 'i': unreferenced local variable
*** WARNING C280 IN LINE 168 OF SOURCE\IR.C: 'j': unreferenced local variable
 194          
 195          void ir_rcv_init(void)
 196          {
 197   1              ir_rcv_t1_timer_cfg(ENABLE);
 198   1              ir_rcv_int = 0;
 199   1      }
 200          
 201          void ir_rcv_deinit(void)
 202          {
 203   1              ir_rcv_t1_timer_cfg(DISABLE);
 204   1              ir_rcv_int = 0;
 205   1      }
 206          
 207          
 208          
 209          static bit ir_out;
 210          static unsigned char ir_cnt;
 211          
 212          void ir_send_isr(void)
 213          {
 214   1              if (ir_out)
 215   1              {
 216   2                      IR_SEND = !IR_SEND;
 217   2              }
 218   1      
 219   1              if (ir_cnt)
 220   1              {
 221   2                      ir_cnt--;
 222   2              }
 223   1      }
 224          
 225          void ir_send_t0_timer_cfg(bit enable)
 226          {
 227   1              TIM_InitTypeDef tim_type;
 228   1      
 229   1              tim_type.TIM_Mode = TIM_16BitAutoReload;
 230   1              tim_type.TIM_Polity = 1;
 231   1              tim_type.TIM_Interrupt = enable;
 232   1              tim_type.TIM_ClkSource = TIM_CLOCK_12T;
 233   1              tim_type.TIM_ClkOut = DISABLE;
 234   1              tim_type.TIM_Value = 65536 - MAIN_Fosc / (38000 * 2);
 235   1              tim_type.TIM_Run = enable;
 236   1              tim_type.TIM_Isr = ir_send_isr;
 237   1              Timer_Inilize(Timer0, &tim_type);
 238   1      }
 239          
 240          bit ir_send(unsigned char *key)
 241          {
 242   1              // TODO:
 243   1              key = key;
 244   1              return 0;
 245   1      }
C51 COMPILER V7.08   IR                           12/06/2015 11:23:58 PAGE 5   

 246          
 247          void ir_send_init(void)
 248          {
 249   1              IR_SEND = 1;
 250   1              ir_out = 0;
 251   1              ir_cnt = 0;
 252   1              ir_send_t0_timer_cfg(ENABLE);
 253   1      }
 254          
 255          void ir_send_deinit(void)
 256          {
 257   1              ir_send_t0_timer_cfg(DISABLE);
 258   1              IR_SEND = 1;
 259   1              ir_out = 0;
 260   1              ir_cnt = 0;
 261   1      }
 262          
 263          
 264          bit check_ir_loop(void)
 265          {
 266   1              unsigned char n = 2;
 267   1      
 268   1              ir_send_init();
 269   1      
 270   1              do {
 271   2                      if (ir_rcv_int)
 272   2                      {
 273   3                              break;
 274   3                      }
 275   2                      ir_cnt = 10;
 276   2                      ir_out = 1;
 277   2                      while (ir_cnt);
 278   2                      ir_out = 0;
 279   2      
 280   2                      if (!ir_rcv_int)
 281   2                      {
 282   3                              break;
 283   3                      }
 284   2                      ir_rcv_int = 0;
 285   2                      Timer1_InterruptEnable();
 286   2      
 287   2                      delay_ms(1);
 288   2              } while (--n);
 289   1      
 290   1              ir_send_deinit();
 291   1      
 292   1              return (n == 0);
 293   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    529    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      45
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)

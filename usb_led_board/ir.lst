C51 COMPILER V7.08   IR                           12/06/2015 18:14:15 PAGE 1   


C51 COMPILER V7.08, COMPILATION OF MODULE IR
OBJECT MODULE PLACED IN source\ir.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE source\ir.c INCDIR(include) DEBUG 
                    -OBJECTEXTEND PRINT(.\ir.lst) PAGEWIDTH(79) PAGELENGTH(66) SRC(.\ir.SRC)

line level    source

   1          /*
   2           * ir
   3           * using timer1 counter to invode interrupt because STC15F104E's 
             -ex int error.
   4           * timer0 is used to calculate high/low level's time.
   5          */
   6          
   7          #include "ir.h"
   8          #include "timer.h"
   9          #include "delay.h"
  10          #include "soft_uart.h"
  11          
  12          
  13          //#define CONFIG_RC3_CODE
  14          
  15          #pragma asm
  16          IR_SEND      BIT     P3.4
  17          #pragma endasm
  18          
  19          static bit ir_rcv_int = 0;
  20          
  21          
  22          void ir_rcv_isr(void)
  23          {
  24   1          Timer1_InterruptDisable();
  25   1          ir_rcv_int = 1;
  26   1      }
  27          
  28          void ir_rcv_t0_timer_cfg(void)
  29          {
  30   1          TIM_InitTypeDef tim_type;
  31   1      
  32   1          tim_type.TIM_Mode = TIM_16BitAutoReload;
  33   1          tim_type.TIM_Polity = 1;
  34   1          tim_type.TIM_Interrupt = DISABLE;
  35   1          tim_type.TIM_ClkSource = TIM_CLOCK_12T;
  36   1          tim_type.TIM_ClkOut = DISABLE;
  37   1          tim_type.TIM_Value = 0;
  38   1          tim_type.TIM_Run = DISABLE;
  39   1          tim_type.TIM_Isr = 0;
  40   1          Timer_Inilize(Timer0, &tim_type);
  41   1      }
  42          
  43          void ir_rcv_t1_timer_cfg(bit enable)
  44          {
  45   1          TIM_InitTypeDef tim_type;
  46   1      
  47   1          tim_type.TIM_Mode = TIM_16BitAutoReload;
  48   1          tim_type.TIM_Polity = PolityLow;
  49   1          tim_type.TIM_Interrupt = enable;
  50   1          tim_type.TIM_ClkSource = TIM_CLOCK_Ext;
  51   1          tim_type.TIM_ClkOut = DISABLE;
  52   1          tim_type.TIM_Value = 0xFFFF;
  53   1          tim_type.TIM_Run = enable;
  54   1          tim_type.TIM_Isr = ir_rcv_isr;
  55   1          Timer_Inilize(Timer1, &tim_type);
C51 COMPILER V7.08   IR                           12/06/2015 18:14:15 PAGE 2   

  56   1      }
  57          
  58          static unsigned int Ir_Get_Low()
  59          {
  60   1          unsigned int t = 0;
  61   1      
  62   1          TL0 = 0;
  63   1          TH0 = 0;
  64   1          TR0 = 1;
  65   1          while (!IR_REV && !(TH0 & 0x80));
  66   1      
  67   1          TR0 = 0;
  68   1          t = TH0;
  69   1          t <<= 8;
  70   1          t |= TL0;
  71   1      
  72   1          return t;
  73   1      }
  74          
  75          static unsigned int Ir_Get_High()
  76          {
  77   1          unsigned int t = 0;
  78   1      
  79   1          TL0 = 0;
  80   1          TH0 = 0;
  81   1          TR0 = 1;
  82   1          while (IR_REV && !(TH0 & 0x80));
  83   1      
  84   1          TR0 = 0;
  85   1          t = TH0;
  86   1          t <<= 8;
  87   1          t |= TL0;
  88   1      
  89   1          return t;
  90   1      }
  91          
  92          static bit nec_decode(unsigned char *key)
  93          {
  94   1          unsigned int temp;
  95   1          char i,j;
  96   1      
  97   1          temp = Ir_Get_High();
  98   1          if ((temp < 3686) || (temp > 4608)) {
  99   2              return 0;
 100   2          }
 101   1      
 102   1          for (i=0; i<4; i++) {
 103   2              for (j=0; j<8; j++) {
 104   3                  temp = Ir_Get_Low();
 105   3                  if ((temp < 184) || (temp > 737)) //200~800us
 106   3                      return 0;
 107   3      
 108   3                  temp = Ir_Get_High();
 109   3                  if ((temp < 184) || (temp > 1843)) //200~2000us
 110   3                      return 0;
 111   3      
 112   3                  key[i] >>= 1;
 113   3                  if (temp > 1032) //1120us
 114   3                      key[i] |= 0x80;
 115   3              }
 116   2          }
 117   1      
 118   1          return 1;
 119   1      }
C51 COMPILER V7.08   IR                           12/06/2015 18:14:15 PAGE 3   

 120          
 121          #ifdef CONFIG_RC3_CODE
              static bit rc5_decode(unsigned char *key)
              {
                  unsigned int temp, c = 0;
                  bit state = 1;
                  char i = 0, j;
              
                  while (1) { //13 bit
                      temp = Ir_Get_High();
                      test[2] = temp;
                      if ((temp < 300) || (temp > 900)) //200~800us
                          goto err;
              
                      if (temp > 600) {
                          state = !state;
                          i++;
                      }
                      c |= state;
                      c <<= 1;
                      i++;
              
                      temp = Ir_Get_Low();
                      test[3] = temp;
                      if ((temp < 300) || (temp > 900)) //200~800us
                          goto err;
              
                      if (temp > 600) {
                          state = !state;
                          i++;
                      }
                      c |= state;
                      c <<= 1;
                      i++;
                  }
              
              err:
                  return 1;
              }
              #endif
 160          
 161          bit ir_rcv(unsigned char *key)
 162          {
 163   1          unsigned int temp;
 164   1          bit ret = 0;
 165   1          char i,j;
 166   1      
 167   1          if (!ir_rcv_int) {
 168   2              return 0;
 169   2          }
 170   1      
 171   1          ir_rcv_t0_timer_cfg();
 172   1      
 173   1          temp = Ir_Get_Low();
 174   1          if (temp > 3000 && temp < 8755) {
 175   2              ret = nec_decode(key);
 176   2          }
 177   1      #ifdef CONFIG_RC3_CODE
                  else if (temp <= 3000) {
                      ret = rc5_decode(key);
                  }
              #endif
 182   1      
 183   1          ir_rcv_int = 0;
C51 COMPILER V7.08   IR                           12/06/2015 18:14:15 PAGE 4   

 184   1          Timer1_InterruptEnable();
 185   1      
 186   1          return ret;
 187   1      }
*** WARNING C280 IN LINE 165 OF SOURCE\IR.C: 'i': unreferenced local variable
*** WARNING C280 IN LINE 165 OF SOURCE\IR.C: 'j': unreferenced local variable
 188          
 189          void ir_rcv_init(void)
 190          {
 191   1          ir_rcv_t1_timer_cfg(ENABLE);
 192   1          ir_rcv_int = 0;
 193   1      }
 194          
 195          void ir_rcv_deinit(void)
 196          {
 197   1          ir_rcv_t1_timer_cfg(DISABLE);
 198   1          ir_rcv_int = 0;
 199   1      }
 200          
 201          
 202          
 203          static bit ir_out;
 204          static unsigned char ir_cnt;
 205          
 206          void ir_send_isr(void)
 207          {
 208   1          if (ir_out) {
 209   2              IR_SEND = !IR_SEND;
 210   2          }
 211   1      
 212   1          if (ir_cnt) {
 213   2              ir_cnt--;
 214   2          }
 215   1      }
 216          
 217          void ir_send_t0_timer_cfg(bit enable)
 218          {
 219   1          TIM_InitTypeDef tim_type;
 220   1      
 221   1          tim_type.TIM_Mode = TIM_16BitAutoReload;
 222   1          tim_type.TIM_Polity = 1;
 223   1          tim_type.TIM_Interrupt = enable;
 224   1          tim_type.TIM_ClkSource = TIM_CLOCK_12T;
 225   1          tim_type.TIM_ClkOut = DISABLE;
 226   1          tim_type.TIM_Value = 65536 - MAIN_Fosc / (38000 * 2);
 227   1          tim_type.TIM_Run = enable;
 228   1          tim_type.TIM_Isr = ir_send_isr;
 229   1          Timer_Inilize(Timer0, &tim_type);
 230   1      }
 231          
 232          
 233          #pragma asm
 234                  // 1 cycle = 1/38K = 291 clock = 145 + 146
 235          CYCLE:  SETB    IR_SEND         // 4
 236                  NOP                     // 1
 237                  MOV     R0,     #33     // 2
 238                  DJNZ    R0,     $       // 4 * 33 = 132
 239          
 240                  CLR     IR_SEND         // 4
 241                  MOV     R0,     #33     // 2
 242                  DJNZ    R0,     $       // 4 * 33 = 132
 243                  RET                     // 4
 244          
 245                  // 0 bit = cycle(560us) + 0(560us) = cycle(21 cycle) + 0(
C51 COMPILER V7.08   IR                           12/06/2015 18:14:15 PAGE 5   

             -6193.152 = 4*12*129 clock)
 246          IRS0:   MOV     R1,     #21     // 2
 247          CC1:    LCALL   CYCLE           // 6
 248                  DJNZ    R1,     CC1     // 4
 249          
 250                  MOV     R2,     #12    // 2
 251          CC2:    MOV     R1,     #129    // 2
 252                  DJNZ    R1,     $       // 4
 253                  DJNZ    R2,     CC2     // 4
 254                  RET
 255          
 256                  // 1 bit = cycle(560us) + 0(1690us) = cycle(21 cycle) + 0
             -(18690.048 = 4*32*146 clock)
 257          IRS1:   MOV     R1,     #21     // 2
 258          CC3:    LCALL   CYCLE           // 6
 259                  DJNZ    R1,     CC3     // 4
 260          
 261                  MOV     R2,     #32     // 2
 262          CC4:    MOV     R1,     #146    // 2
 263                  DJNZ    R1,     $       // 4
 264                  DJNZ    R2,     CC4     // 4
 265                  RET
 266          #pragma endasm
 267          
 268          bit ir_send(unsigned char *key)
 269          {
 270   1      #pragma asm
 271   1              PUSH    ACC
 272   1              MOV     ACC,    R0
 273   1              PUSH    ACC
 274   1              MOV     ACC,    R1
 275   1              PUSH    ACC
 276   1              MOV     ACC,    R2
 277   1              PUSH    ACC
 278   1              MOV     ACC,    R3
 279   1              PUSH    ACC
 280   1              MOV     ACC,    R4
 281   1              PUSH    ACC
 282   1              MOV     ACC,    R5
 283   1              PUSH    ACC
 284   1      
 285   1              MOV     A,      R1
 286   1              MOV     R5,     A
 287   1      
 288   1              // send start code: 0(9000us = 342 cycle = 171 + 171) + 1
             -(4500us = 49767 clock = 4 * 49 * 255)
 289   1              MOV     R1,     #170    // 2
 290   1              MOV     R2,     #170    // 2
 291   1      C1:     LCALL   CYCLE           // 6
 292   1              DJNZ    R1,     C1      // 4
 293   1      C2:     LCALL   CYCLE           // 6
 294   1              DJNZ    R2,     C2      // 4
 295   1      
 296   1              MOV     R2,     #49     // 2
 297   1      C3:     MOV     R1,     #255    // 2
 298   1              DJNZ    R1,     $       // 4
 299   1              DJNZ    R2,     C3      // 4
 300   1      
 301   1              // send byte
 302   1              MOV     R4,     #4      //
 303   1      C7:     MOV     A,      R5
 304   1              MOV     R0,     A
 305   1              MOV     A,      @R0     //
 306   1              INC     R5
C51 COMPILER V7.08   IR                           12/06/2015 18:14:15 PAGE 6   

 307   1              MOV     R3,     #8      //
 308   1      C6:     RRC     A               // 1
 309   1              JC      C4              // 3
 310   1              LCALL   IRS0            // 6
 311   1              LJMP    C5
 312   1      C4:     LCALL   IRS1            // 6
 313   1      C5:     DJNZ    R3,     C6      // 4
 314   1              DJNZ    R4,     C7      // 4
 315   1      
 316   1              MOV     R0,     #0FFH
 317   1              DJNZ    R0,     $
 318   1      
 319   1              POP     ACC
 320   1              MOV     R5,     ACC
 321   1              POP     ACC
 322   1              MOV     R4,     ACC
 323   1              POP     ACC
 324   1              MOV     R3,     ACC
 325   1              POP     ACC
 326   1              MOV     R2,     ACC
 327   1              POP     ACC
 328   1              MOV     R1,     ACC
 329   1              POP     ACC
 330   1              MOV     R0,     ACC
 331   1              POP     ACC
 332   1      #pragma endasm
 333   1      
 334   1          return 0;
 335   1      }
*** WARNING C280 IN LINE 268 OF SOURCE\IR.C: 'key': unreferenced local variable
 336          
 337          void ir_send_init(void)
 338          {
 339   1          IR_SEND = 1;
 340   1          ir_out = 0;
 341   1          ir_cnt = 0;
 342   1          ir_send_t0_timer_cfg(ENABLE);
 343   1      }
 344          
 345          void ir_send_deinit(void)
 346          {
 347   1          ir_send_t0_timer_cfg(DISABLE);
 348   1          IR_SEND = 1;
 349   1          ir_out = 0;
 350   1          ir_cnt = 0;
 351   1      }
 352          
 353          
 354          bit check_ir_loop(void)
 355          {
 356   1          unsigned char n = 2;
 357   1      
 358   1          ir_send_init();
 359   1      
 360   1          do {
 361   2              if (ir_rcv_int) {
 362   3                  break;
 363   3              }
 364   2              ir_cnt = 10;
 365   2              ir_out = 1;
 366   2              while (ir_cnt);
 367   2              ir_out = 0;
 368   2      
 369   2              if (!ir_rcv_int) {
C51 COMPILER V7.08   IR                           12/06/2015 18:14:15 PAGE 7   

 370   3                  break;
 371   3              }
 372   2              ir_rcv_int = 0;
 373   2              Timer1_InterruptEnable();
 374   2      
 375   2              delay_ms(1);
 376   2          } while (--n);
 377   1      
 378   1          ir_send_deinit();
 379   1      
 380   1          return (n == 0);
 381   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    718    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      48
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
